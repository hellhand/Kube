<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Task 001.02 – Baseline GLFW Window</title>
  <link rel="stylesheet" href="shared.css">
</head>
<body>
<main>
  <header>
    <h1>Task 001.02 – Baseline GLFW Window (No API)</h1>
    <p class="lead">Set up Go module, dependencies, and a minimal window loop.</p>
  </header>
  <section>
    <h2>1) Init module & dependencies</h2>
<pre><code>go mod init Kube
go get github.com/vulkan-go/glfw/v3.3/glfw@v0.0.0-20210402172934-58379a80228d
go get github.com/vulkan-go/vulkan@v0.0.0-20221209234627-c0a353ae26c8
go get github.com/go-gl/mathgl/mgl32@v1.2.0
</code></pre>
  </section>
  <section>
    <h2>2) Baseline window code</h2>
<pre><code class="language-go">package main

import (
  "log"
  "runtime"
  "time"
  "github.com/vulkan-go/glfw/v3.3/glfw"
)

func init() { runtime.LockOSThread() }

func main() {
  if err := glfw.Init(); err != nil { log.Fatalf("init glfw: %v", err) }
  defer glfw.Terminate()

  glfw.WindowHint(glfw.ClientAPI, glfw.NoAPI)
  win, err := glfw.CreateWindow(800, 600, "Baseline", nil, nil)
  if err != nil { log.Fatalf("create window: %v", err) }
  defer win.Destroy()

  // wait for non-zero framebuffer size
  for {
    w, h := win.GetFramebufferSize()
    if w > 0 && h > 0 { break }
    glfw.WaitEventsTimeout(0.01)
  }

  win.SetKeyCallback(func(w *glfw.Window, key glfw.Key, scancode int, action glfw.Action, mods glfw.ModifierKey) {
    if key == glfw.KeyEscape && action == glfw.Press { w.SetShouldClose(true) }
  })

  for !win.ShouldClose() {
    glfw.PollEvents()
    time.Sleep(1 * time.Millisecond)
  }
}
</code></pre>
  </section>
  <section>
    <h2>3) Run it</h2>
<pre><code>go run .
</code></pre>
    <p>You should see an empty window that closes on ESC. No Vulkan yet.</p>
  </section>
  <section>
    <h2>4) What each call does (expanded)</h2>
    <p>This tiny loop is the backbone for the rest of the tutorial. Understand each line before adding Vulkan:</p>
    <ul>
      <li><code>runtime.LockOSThread()</code>: Vulkan and GLFW expect API calls from one thread; locking now prevents subtle crashes later.</li>
      <li><code>glfw.WindowHint(glfw.ClientAPI, glfw.NoAPI)</code>: ensures GLFW does not create an OpenGL context.</li>
      <li>Framebuffer wait loop: on some WMs the framebuffer is 0×0 until the window is shown; the loop avoids creating a zero-sized swapchain.</li>
      <li>Key callback: ESC closes; later we also hook SPACE to pause rotation.</li>
      <li>Main loop: <code>PollEvents()</code> keeps the window responsive; the tiny sleep keeps CPU usage reasonable before we start rendering.</li>
    </ul>
<pre><code class="language-go">// Minimal loop you can copy into other experiments
for !win.ShouldClose() {
  glfw.PollEvents()
  // (render happens in later steps)
}</code></pre>
    <p>If something breaks later, comment out all Vulkan and return to this loop to confirm window creation still works.</p>
  </section>
  <div class="nav"><a href="index.html">← Back to Hub</a> <a href="step-002-milestone-instance.html">Next →</a></div>
</main>
</body>
</html>
