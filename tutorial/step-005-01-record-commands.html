<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Task 005.01 – Record Draw Commands</title>
  <link rel="stylesheet" href="shared.css">
</head>
<body>
<main>
  <header>
    <h1>Task 005.01 – Record Draw Commands for Cube</h1>
    <p class="lead">Bind pipeline/resources and issue indexed draw for the cube each frame.</p>
  </header>
  <section>
    <h2>Command buffer contents</h2>
    <ol>
      <li>Begin command buffer.</li>
      <li>Begin render pass with clear values (color + depth).</li>
      <li>Bind graphics pipeline.</li>
      <li>Bind vertex buffer (binding 0) and index buffer (uint32 indices).</li>
      <li>Bind descriptor set for the current swapchain image.</li>
      <li><code>vkCmdDrawIndexed</code> with index count = 36.</li>
      <li>End render pass.</li>
      <li>End command buffer.</li>
    </ol>
<pre><code class="language-go">vulkan.CmdBeginRenderPass(cb, &rpInfo, vulkan.SubpassContentsInline)
vulkan.CmdBindPipeline(cb, vulkan.PipelineBindPointGraphics, a.pipeline)
vulkan.CmdBindVertexBuffers(cb, 0, 1, []vulkan.Buffer{a.vertexBuffer}, []vulkan.DeviceSize{0})
vulkan.CmdBindIndexBuffer(cb, a.indexBuffer, 0, vulkan.IndexTypeUint32)
vulkan.CmdBindDescriptorSets(cb, vulkan.PipelineBindPointGraphics, a.pipelineLayout, 0,
  1, []vulkan.DescriptorSet{a.descriptorSets[imageIndex]}, 0, nil)
vulkan.CmdDrawIndexed(cb, uint32(len(cubeIndices)), 1, 0, 0, 0)
vulkan.CmdEndRenderPass(cb)
</code></pre>
  </section>
  <section>
    <h2>Submission flow</h2>
    <ol>
      <li>Wait fence for current frame.</li>
      <li>Acquire swapchain image (signal imageAvailable).</li>
      <li>Reset fence, reset command buffer, record as above.</li>
      <li>Submit: wait imageAvailable at COLOR_ATTACHMENT_OUTPUT, signal renderFinished.</li>
      <li>Present: wait renderFinished.</li>
    </ol>
<pre><code class="language-go">// Acquire
res := vulkan.AcquireNextImage(a.device, a.swapchain, vulkan.MaxUint64,
  a.imageAvailable[frame], vulkan.Fence(vulkan.NullHandle), &imageIndex)
// Record command buffer for imageIndex here

waitStages := []vulkan.PipelineStageFlags{vulkan.PipelineStageFlags(vulkan.PipelineStageColorAttachmentOutputBit)}
submit := vulkan.SubmitInfo{
  SType:                vulkan.StructureTypeSubmitInfo,
  WaitSemaphoreCount:   1,
  PWaitSemaphores:      []vulkan.Semaphore{a.imageAvailable[frame]},
  PWaitDstStageMask:    waitStages,
  CommandBufferCount:   1,
  PCommandBuffers:      []vulkan.CommandBuffer{a.commandBuffers[imageIndex]},
  SignalSemaphoreCount: 1,
  PSignalSemaphores:    []vulkan.Semaphore{a.renderFinished[frame]},
}
vulkan.QueueSubmit(a.graphicsQueue, 1, []vulkan.SubmitInfo{submit}, a.inFlightFences[frame])

present := vulkan.PresentInfo{
  SType:              vulkan.StructureTypePresentInfo,
  WaitSemaphoreCount: 1,
  PWaitSemaphores:    []vulkan.Semaphore{a.renderFinished[frame]},
  SwapchainCount:     1,
  PSwapchains:        []vulkan.Swapchain{a.swapchain},
  PImageIndices:      []uint32{imageIndex},
}
vulkan.QueuePresent(a.presentQueue, &present)</code></pre>
  </section>
  <section>
    <h2>Notes for beginners</h2>
    <p><strong>Command buffer reuse.</strong> We allocate one primary command buffer per swapchain image. Before recording, reset it with <code>vkResetCommandBuffer</code> (available because the pool was created with the RESET flag).</p>
    <p><strong>Stage mask.</strong> The wait stage for the acquire semaphore is <code>COLOR_ATTACHMENT_OUTPUT</code> because the swapchain image is first used as a color attachment; using an earlier stage can trigger validation warnings.</p>
    <p><strong>Fence order.</strong> Wait on the in-flight fence at the start of the frame, reset it right before <code>QueueSubmit</code>, and let <code>QueueSubmit</code> signal it on completion. This avoids GPU/CPU race conditions when resizing or skipping frames.</p>
<pre><code class="language-go">// Fence handling around submit
vulkan.WaitForFences(a.device, 1, []vulkan.Fence{a.inFlightFences[frame]}, vulkan.True, vulkan.MaxUint64)
vulkan.ResetFences(a.device, 1, []vulkan.Fence{a.inFlightFences[frame]})
// ... record cmd buffer ...
vulkan.QueueSubmit(a.graphicsQueue, 1, []vulkan.SubmitInfo{submit}, a.inFlightFences[frame])</code></pre>
    <p>If you see “out of date” or “suboptimal” on present, recreate the swapchain (next step) and keep the same submission pattern.</p>
  </section>
  <div class="nav"><a href="index.html">← Back to Hub</a> <a href="step-005-02-resize-recreate.html">Next →</a></div>
</main>
</body>
</html>
