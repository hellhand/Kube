<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Task 004.02 – Buffers, UBO, and Descriptors</title>
  <link rel="stylesheet" href="shared.css">
</head>
<body>
<main>
  <header>
    <h1>Task 004.02 – Cube Buffers, Uniforms, and Descriptors</h1>
    <p class="lead">Create vertex/index buffers, per-frame UBOs, and descriptor sets to feed the pipeline.</p>
  </header>
  <section>
    <h2>1) Vertex/index data</h2>
    <p>Use 24 vertices (4 per face) to get correct UVs on each face; indexed draw:</p>
<pre><code class="language-go">type vertex struct {
  pos   mgl32.Vec3
  color mgl32.Vec3
  uv    mgl32.Vec2
}
var cubeVertices = []vertex{ /* 24 entries, per-face UVs */ }
var cubeIndices  = []uint32{ /* 36 indices, 6 faces */ }</code></pre>
  </section>
  <section>
    <h2>2) Buffers</h2>
    <ul>
      <li>Create host-visible, coherent buffers for vertices and indices (usage: vertex/index).</li>
      <li>Map, copy the data, unmap.</li>
    </ul>
<pre><code class="language-go">vbSize := vulkan.DeviceSize(len(cubeVertices)) * vulkan.DeviceSize(unsafe.Sizeof(vertex{}))
buf, mem, _ := a.createBuffer(vbSize,
  vulkan.BufferUsageFlags(vulkan.BufferUsageVertexBufferBit),
  vulkan.MemoryPropertyHostVisibleBit|vulkan.MemoryPropertyHostCoherentBit)
var data unsafe.Pointer
vulkan.MapMemory(a.device, mem, 0, vbSize, 0, &data)
dst := (*[1<<30]byte)(data)[:vbSize:vbSize]
copy(dst, verticesToBytes(cubeVertices))
vulkan.UnmapMemory(a.device, mem)
a.vertexBuffer, a.vertexBufferMemory = buf, mem</code></pre>
  </section>
  <section>
    <h2>3) Uniform buffers</h2>
<pre><code class="language-go">type uniformBufferObject struct {
  Model mgl32.Mat4
  View  mgl32.Mat4
  Proj  mgl32.Mat4
}</code></pre>
    <p>Update per frame (host-visible mapping):</p>
<pre><code class="language-go">ubo := uniformBufferObject{Model: model, View: view, Proj: proj}
size := vulkan.DeviceSize(unsafe.Sizeof(ubo))
var data unsafe.Pointer
if res := vulkan.MapMemory(a.device, a.uniformBuffersMemory[imageIndex], 0, size, 0, &data); res != vulkan.Success {
  return fmt.Errorf("map uniform buffer: %w", vulkan.Error(res))
}
dst := (*[1<<30]byte)(data)[:size:size]
src := (*[1<<30]byte)(unsafe.Pointer(&ubo))[:size:size]
copy(dst, src)
vulkan.UnmapMemory(a.device, a.uniformBuffersMemory[imageIndex])</code></pre>
    <ul>
      <li>Allocate one UBO per swapchain image (host-visible, coherent).</li>
      <li>Update each frame with model/view/proj matrices.</li>
    </ul>
  </section>
  <section>
    <h2>4) Descriptor sets</h2>
    <ul>
      <li>Descriptor set layout: binding 0 = UBO (vertex), binding 1 = combined image sampler (fragment).</li>
      <li>Allocate one descriptor set per swapchain image from a pool sized for UBO + sampler counts.</li>
      <li>Write descriptors: buffer info for binding 0, image info (sampler/view, layout SHADER_READ_ONLY_OPTIMAL) for binding 1.</li>
    </ul>
<pre><code class="language-go">bufferInfo := vulkan.DescriptorBufferInfo{
  Buffer: a.uniformBuffers[i],
  Offset: 0,
  Range:  vulkan.DeviceSize(unsafe.Sizeof(uniformBufferObject{})),
}
imageInfo := vulkan.DescriptorImageInfo{
  Sampler:     a.textureSampler,
  ImageView:   a.textureImageView,
  ImageLayout: vulkan.ImageLayoutShaderReadOnlyOptimal,
}
writeUBO := vulkan.WriteDescriptorSet{
  SType: vulkan.StructureTypeWriteDescriptorSet,
  DstSet: a.descriptorSets[i],
  DstBinding: 0,
  DescriptorType: vulkan.DescriptorTypeUniformBuffer,
  DescriptorCount: 1,
  PBufferInfo: []vulkan.DescriptorBufferInfo{bufferInfo},
}
writeSampler := vulkan.WriteDescriptorSet{
  SType: vulkan.StructureTypeWriteDescriptorSet,
  DstSet: a.descriptorSets[i],
  DstBinding: 1,
  DescriptorType: vulkan.DescriptorTypeCombinedImageSampler,
  DescriptorCount: 1,
  PImageInfo: []vulkan.DescriptorImageInfo{imageInfo},
}
vulkan.UpdateDescriptorSets(a.device, 2, []vulkan.WriteDescriptorSet{writeUBO, writeSampler}, 0, nil)</code></pre>
  </section>
  <section>
    <h2>Extra guidance</h2>
    <p><strong>Picking memory types.</strong> The helper <code>createBuffer</code> walks <code>vkGetPhysicalDeviceMemoryProperties</code> to find a memory type that satisfies flags (e.g., HOST_VISIBLE | HOST_COHERENT for CPU-updated data; DEVICE_LOCAL for GPU-only data). Reuse that helper for vertex, index, and uniform buffers.</p>
<pre><code class="language-go">func (a *VulkanApp) createBuffer(size vulkan.DeviceSize, usage vulkan.BufferUsageFlags, props vulkan.MemoryPropertyFlags) (vulkan.Buffer, vulkan.DeviceMemory, error) {
  bufInfo := vulkan.BufferCreateInfo{SType: vulkan.StructureTypeBufferCreateInfo, Size: size, Usage: usage, SharingMode: vulkan.SharingModeExclusive}
  var buf vulkan.Buffer
  vulkan.CreateBuffer(a.device, &bufInfo, nil, &buf)
  var memReq vulkan.MemoryRequirements
  vulkan.GetBufferMemoryRequirements(a.device, buf, &memReq)
  memType := a.findMemoryType(memReq.MemoryTypeBits, props)
  alloc := vulkan.MemoryAllocateInfo{SType: vulkan.StructureTypeMemoryAllocateInfo, AllocationSize: memReq.Size, MemoryTypeIndex: memType}
  var mem vulkan.DeviceMemory
  vulkan.AllocateMemory(a.device, &alloc, nil, &mem)
  vulkan.BindBufferMemory(a.device, buf, mem, 0)
  return buf, mem, nil
}</code></pre>
    <p><strong>Descriptor pool sizing.</strong> The pool must cover <em>per swapchain image</em> UBO and sampler descriptors. For N swapchain images, set pool sizes to N for both <code>UNIFORM_BUFFER</code> and <code>COMBINED_IMAGE_SAMPLER</code>, and allocate N descriptor sets from that pool. This prevents allocation failures when resizing the window.</p>
  </section>
  <div class="nav"><a href="index.html">← Back to Hub</a> <a href="step-005-milestone-render-loop.html">Next →</a></div>
</main>
</body>
</html>
