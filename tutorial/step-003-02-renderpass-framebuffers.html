<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Task 003.02 – Render Pass, Framebuffers, Sync Loop</title>
  <link rel="stylesheet" href="shared.css">
</head>
<body>
<main>
  <header>
    <h1>Task 003.02 – Render Pass, Framebuffers, and Sync</h1>
    <p class="lead">Define render pass, build framebuffers, allocate command buffers, and wire per-frame sync for a clear-color loop.</p>
  </header>
  <section>
    <h2>1) Render pass</h2>
    <ul>
      <li>Attachments: color (swapchain format, layout PRESENT at end), depth (depth format, layout DEPTH_STENCIL_ATTACHMENT_OPTIMAL).</li>
      <li>Subpass: references color + depth attachments.</li>
    </ul>
<pre><code class="language-go">colorAttachment := vulkan.AttachmentDescription{
  Format:         a.swapchainFormat,
  Samples:        vulkan.SampleCount1Bit,
  LoadOp:         vulkan.AttachmentLoadOpClear,
  StoreOp:        vulkan.AttachmentStoreOpStore,
  InitialLayout:  vulkan.ImageLayoutUndefined,
  FinalLayout:    vulkan.ImageLayoutPresentSrc,
}
depthAttachment := vulkan.AttachmentDescription{
  Format:        a.depthFormat,
  Samples:       vulkan.SampleCount1Bit,
  LoadOp:        vulkan.AttachmentLoadOpClear,
  StoreOp:       vulkan.AttachmentStoreOpDontCare,
  InitialLayout: vulkan.ImageLayoutUndefined,
  FinalLayout:   vulkan.ImageLayoutDepthStencilAttachmentOptimal,
}
// Define subpass and create render pass with both attachments.</code></pre>
  </section>
  <section>
    <h2>2) Framebuffers</h2>
    <ul>
      <li>One framebuffer per swapchain image view plus the depth view.</li>
    </ul>
<pre><code class="language-go">for i := range a.swapchainViews {
  attachments := []vulkan.ImageView{a.swapchainViews[i], a.depthImageView}
  fbInfo := vulkan.FramebufferCreateInfo{
    SType:           vulkan.StructureTypeFramebufferCreateInfo,
    RenderPass:      a.renderPass,
    AttachmentCount: uint32(len(attachments)),
    PAttachments:    attachments,
    Width:           a.swapchainExtent.Width,
    Height:          a.swapchainExtent.Height,
    Layers:          1,
  }
  fb := vulkan.Framebuffer(vulkan.NullHandle)
  vulkan.CreateFramebuffer(a.device, &fbInfo, nil, &fb)
  a.framebuffers = append(a.framebuffers, fb)
}</code></pre>
  </section>
  <section>
    <h2>3) Command pool/buffers</h2>
    <ul>
      <li>Create command pool (graphics queue family).</li>
      <li>Allocate primary command buffers = swapchain image count.</li>
    </ul>
<pre><code class="language-go">poolInfo := vulkan.CommandPoolCreateInfo{
  SType: vulkan.StructureTypeCommandPoolCreateInfo,
  Flags: vulkan.CommandPoolCreateFlags(vulkan.CommandPoolCreateResetCommandBufferBit),
  QueueFamilyIndex: a.queues.graphicsFamily,
}
vulkan.CreateCommandPool(a.device, &poolInfo, nil, &a.commandPool)

allocInfo := vulkan.CommandBufferAllocateInfo{
  SType: vulkan.StructureTypeCommandBufferAllocateInfo,
  CommandPool: a.commandPool,
  Level: vulkan.CommandBufferLevelPrimary,
  CommandBufferCount: uint32(len(a.swapchainImages)),
}
a.commandBuffers = make([]vulkan.CommandBuffer, len(a.swapchainImages))
vulkan.AllocateCommandBuffers(a.device, &allocInfo, a.commandBuffers)</code></pre>
  </section>
  <section>
    <h2>4) Sync objects</h2>
    <ul>
      <li>Per-frame: imageAvailable semaphore, renderFinished semaphore, inFlight fence (start signaled).</li>
      <li>Track images-in-flight fences to avoid double-submitting the same image.</li>
    </ul>
<pre><code class="language-go">semInfo := vulkan.SemaphoreCreateInfo{SType: vulkan.StructureTypeSemaphoreCreateInfo}
fenceInfo := vulkan.FenceCreateInfo{
  SType: vulkan.StructureTypeFenceCreateInfo,
  Flags: vulkan.FenceCreateFlags(vulkan.FenceCreateSignaledBit),
}
// create per-frame semaphores/fences here</code></pre>
  </section>
  <section>
    <h2>5) Clear loop</h2>
    <ol>
      <li>Wait fence, acquire image.</li>
      <li>Record command buffer: begin render pass, clear color/depth, end render pass.</li>
      <li>Submit (wait imageAvailable, signal renderFinished), present (wait renderFinished).</li>
    </ol>
<pre><code class="language-go">clearColor := vulkan.NewClearValue([]float32{0.05, 0.05, 0.05, 1.0})
clearDepth := vulkan.NewClearDepthStencil(1.0, 0)
rpInfo := vulkan.RenderPassBeginInfo{ /* assign framebuffer, area, clears */ }
// Record CB: BeginRenderPass -> (later bind pipeline/draw) -> EndRenderPass
</code></pre>
  </section>
  <section>
    <h2>Detailed walkthrough</h2>
    <p><strong>Render pass layout.</strong> We clear both attachments at load time, store color (so it can be presented), and discard depth (no one reads it later). Final layouts match how the images are used after the render pass: color goes to <code>PRESENT_SRC</code>, depth stays in <code>DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code>.</p>
<pre><code class="language-go">subpass := vulkan.SubpassDescription{
  PipelineBindPoint: vulkan.PipelineBindPointGraphics,
  ColorAttachmentCount: 1,
  PColorAttachments: []vulkan.AttachmentReference{{
    Attachment: 0, Layout: vulkan.ImageLayoutColorAttachmentOptimal,
  }},
  PDepthStencilAttachment: &vulkan.AttachmentReference{
    Attachment: 1, Layout: vulkan.ImageLayoutDepthStencilAttachmentOptimal,
  },
}</code></pre>
    <p><strong>Command buffer contents.</strong> Recording for a single image looks like:</p>
<pre><code class="language-go">vulkan.BeginCommandBuffer(cmd, &vulkan.CommandBufferBeginInfo{
  SType: vulkan.StructureTypeCommandBufferBeginInfo,
})
vulkan.CmdBeginRenderPass(cmd, &rpInfo, vulkan.SubpassContentsInline)
// later: bind pipeline, vertex/index buffers, descriptor sets
vulkan.CmdEndRenderPass(cmd)
vulkan.EndCommandBuffer(cmd)</code></pre>
    <p><strong>Sync timeline.</strong> Wait on the per-frame fence before reusing a command buffer. After <code>vkAcquireNextImageKHR</code>, signal <code>imageAvailable</code>; submit the command buffer waiting on that semaphore, then signal <code>renderFinished</code>. Present waits on <code>renderFinished</code>. The in-flight fence is signaled when the GPU finishes the submission.</p>
  </section>
  <div class="nav"><a href="index.html">← Back to Hub</a> <a href="step-004-milestone-pipeline.html">Next →</a></div>
</main>
</body>
</html>
