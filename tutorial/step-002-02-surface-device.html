<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Task 002.02 – Surface, GPU Selection, Logical Device</title>
  <link rel="stylesheet" href="shared.css">
</head>
<body>
<main>
  <header>
    <h1>Task 002.02 – Surface, GPU Selection, Logical Device</h1>
    <p class="lead">Create the window surface, choose a suitable GPU, and build the logical device with swapchain support.</p>
  </header>
  <section>
    <h2>1) Create surface</h2>
    <ul>
      <li>Use GLFW to create the Vulkan surface bound to the window.</li>
      <li>Store the surface handle for later swapchain creation.</li>
    </ul>
    <p>This connects Vulkan to the actual windowing system (X11 here). Without a surface, swapchains can’t be created, so do this immediately after the instance is ready.</p>
<pre><code class="language-go">var surface vulkan.Surface
if err := glfw.CreateWindowSurface(a.instance, a.window, nil, &surface); err != nil {
  return fmt.Errorf("create surface: %w", err)
}
a.surface = surface</code></pre>
  </section>
  <section>
    <h2>2) Pick physical device</h2>
    <ul>
      <li>Enumerate devices; for each, query queue families for graphics and present support (surface-specific).</li>
      <li>Check device extensions include <code>VK_KHR_swapchain</code>.</li>
      <li>Check swapchain support: at least one format and one present mode.</li>
      <li>Prefer discrete GPU if multiple devices qualify.</li>
    </ul>
    <p>Graphics support alone isn’t enough: the device must also present to our surface and offer swapchain support. If a GPU lacks any of these, skip it.</p>
<pre><code class="language-go">devices := vulkan.PhysicalDeviceSlice(count)
vulkan.EnumeratePhysicalDevices(a.instance, &count, devices)
for _, dev := range devices {
  if supportsQueues(dev, a.surface) && supportsSwapchain(dev) {
    a.physicalDevice = dev
    break
  }
}</code></pre>
  </section>
  <section>
    <h2>3) Create logical device</h2>
    <ul>
      <li>Queue create infos: graphics family (and present if different).</li>
      <li>Enable device extension <code>VK_KHR_swapchain</code>; no extra layers needed on device.</li>
      <li>Call <code>vulkan.CreateDevice</code>, then <code>vulkan.GetDeviceQueue</code> for graphics and present queues; store them.</li>
    </ul>
    <p>The logical device is the handle you’ll use for almost every Vulkan operation. Make sure to fetch the queue handles right after creation.</p>
<pre><code class="language-go">extensions := []string{"VK_KHR_swapchain"}
qInfos := []vulkan.DeviceQueueCreateInfo{{
  SType:            vulkan.StructureTypeDeviceQueueCreateInfo,
  QueueFamilyIndex: graphicsIndex,
  QueueCount:       1,
  PQueuePriorities: []float32{1.0},
}}
createInfo := vulkan.DeviceCreateInfo{
  SType:                   vulkan.StructureTypeDeviceCreateInfo,
  QueueCreateInfoCount:    uint32(len(qInfos)),
  PQueueCreateInfos:       qInfos,
  EnabledExtensionCount:   uint32(len(extensions)),
  PpEnabledExtensionNames: extensions,
}
if res := vulkan.CreateDevice(a.physicalDevice, &createInfo, nil, &a.device); res != vulkan.Success {
  return fmt.Errorf("create device: %w", vulkan.Error(res))
}
vulkan.GetDeviceQueue(a.device, graphicsIndex, 0, &a.graphicsQueue)
vulkan.GetDeviceQueue(a.device, presentIndex, 0, &a.presentQueue)</code></pre>
  </section>
  <section>
    <h2>Walkthrough & pitfalls</h2>
    <p><strong>Queue discovery.</strong> In <code>supportsQueues</code> we call <code>vulkan.GetPhysicalDeviceQueueFamilyProperties</code> to inspect each family. A family is valid if <code>QueueFlags &amp; GraphicsBit</code> is set and <code>vulkan.GetPhysicalDeviceSurfaceSupport</code> reports it can present to the window surface. On some laptops, graphics and present are different queues—handle both.</p>
<pre><code class="language-go">func supportsQueues(dev vulkan.PhysicalDevice, surface vulkan.Surface) (bool, uint32, uint32) {
  count := uint32(0)
  vulkan.GetPhysicalDeviceQueueFamilyProperties(dev, &count, nil)
  props := make([]vulkan.QueueFamilyProperties, count)
  vulkan.GetPhysicalDeviceQueueFamilyProperties(dev, &count, props)
  var gfx, present = uint32(vulkan.QueueFamilyIgnored), uint32(vulkan.QueueFamilyIgnored)
  for i, p := range props {
    if p.QueueFlags&vulkan.QueueFlags(vulkan.QueueGraphicsBit) != 0 { gfx = uint32(i) }
    var supported vulkan.Bool32
    vulkan.GetPhysicalDeviceSurfaceSupport(dev, uint32(i), surface, &supported)
    if supported == vulkan.True { present = uint32(i) }
  }
  return gfx != vulkan.QueueFamilyIgnored && present != vulkan.QueueFamilyIgnored, gfx, present
}</code></pre>
    <p><strong>Extension loading.</strong> After <code>CreateDevice</code>, call <code>vulkan.InitDevice(a.device)</code>. Without it, device-level functions (swapchain, buffers, etc.) would be nil and crash. Keep this call together with queue retrieval so you never forget it.</p>
    <p><strong>Swapchain requirement.</strong> The tutorial intentionally fails fast if <code>VK_KHR_swapchain</code> is missing—there is no sensible fallback. If your driver lacks it, install a newer Vulkan runtime.</p>
  </section>
  <div class="nav"><a href="index.html">← Back to Hub</a> <a href="step-003-milestone-swapchain.html">Next →</a></div>
</main>
</body>
</html>
