<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Task 003.01 – Swapchain, Views, Depth Buffer</title>
  <link rel="stylesheet" href="shared.css">
</head>
<body>
<main>
  <header>
    <h1>Task 003.01 – Swapchain, Views, Depth Buffer</h1>
    <p class="lead">Build the swapchain, create color views, and add a depth image/view.</p>
  </header>
  <section>
    <h2>1) Choose swapchain settings</h2>
    <ul>
      <li>Surface format: prefer SRGB (e.g., <code>B8G8R8A8_SRGB</code>).</li>
      <li>Present mode: FIFO (always available).</li>
      <li>Extent: clamp to surface caps; if current extent is 0, wait until framebuffer has size.</li>
      <li>Image count: min+1, capped by max image count if provided.</li>
    </ul>
<pre><code class="language-go">extent := surfaceCaps.CurrentExtent
if extent.Width == 0 || extent.Height == 0 {
  // wait in app loop until framebuffer size is non-zero
}
imageCount := surfaceCaps.MinImageCount + 1
if surfaceCaps.MaxImageCount > 0 && imageCount > surfaceCaps.MaxImageCount {
  imageCount = surfaceCaps.MaxImageCount
}</code></pre>
  </section>
  <section>
    <h2>2) Create swapchain & image views</h2>
    <ul>
      <li>Create the swapchain with sharing mode (exclusive unless graphics/present differ).</li>
      <li>Fetch images via <code>GetSwapchainImages</code> and create <code>VkImageView</code> for each with color aspect.</li>
    </ul>
<pre><code class="language-go">createInfo := vulkan.SwapchainCreateInfo{
  SType:            vulkan.StructureTypeSwapchainCreateInfo,
  Surface:          a.surface,
  MinImageCount:    imageCount,
  ImageFormat:      surfaceFormat.Format,
  ImageColorSpace:  surfaceFormat.ColorSpace,
  ImageExtent:      extent,
  ImageArrayLayers: 1,
  ImageUsage:       vulkan.ImageUsageFlags(vulkan.ImageUsageColorAttachmentBit),
  ImageSharingMode: vulkan.SharingModeExclusive,
  PreTransform:     surfaceCaps.CurrentTransform,
  CompositeAlpha:   vulkan.CompositeAlphaOpaqueBit,
  PresentMode:      presentMode,
  Clipped:          vulkan.True,
}
// Create swapchain, then:
var count uint32
vulkan.GetSwapchainImages(a.device, a.swapchain, &count, nil)
imgs := make([]vulkan.Image, count)
vulkan.GetSwapchainImages(a.device, a.swapchain, &count, imgs)
for _, img := range imgs {
  view := createImageView(img, a.swapchainFormat, vulkan.ImageAspectFlags(vulkan.ImageAspectColorBit))
  a.swapchainViews = append(a.swapchainViews, view)
}</code></pre>
  </section>
  <section>
    <h2>3) Depth resources</h2>
    <ul>
      <li>Pick a depth format (e.g., D32_SFLOAT) supported with optimal tiling and depth-stencil feature.</li>
      <li>Create an image (width=extent.W, height=extent.H, 1 mip, 1 layer, optimal tiling, usage DEPTH_STENCIL_ATTACHMENT).</li>
      <li>Allocate device-local memory, bind, and create a depth view (aspect depth).</li>
    </ul>
<pre><code class="language-go">depthFormat := pickDepthFormat()
img, mem, _ := a.createImage(extent.Width, extent.Height, depthFormat,
  vulkan.ImageTilingOptimal,
  vulkan.ImageUsageFlags(vulkan.ImageUsageDepthStencilAttachmentBit),
  vulkan.MemoryPropertyDeviceLocalBit)
view, _ := a.createImageView(img, depthFormat, vulkan.ImageAspectFlags(vulkan.ImageAspectDepthBit))
a.depthImage, a.depthImageMemory, a.depthImageView = img, mem, view</code></pre>
    <p>Helper: find depth format:</p>
<pre><code class="language-go">func pickDepthFormat() vulkan.Format {
  candidates := []vulkan.Format{
    vulkan.FormatD32Sfloat, vulkan.FormatD32SfloatS8Uint, vulkan.FormatD24UnormS8Uint,
  }
  for _, f := range candidates {
    var props vulkan.FormatProperties
    vulkan.GetPhysicalDeviceFormatProperties(a.physicalDevice, f, &props)
    props.Deref()
    if props.OptimalTilingFeatures &amp; vulkan.FormatFeatureFlags(vulkan.FormatFeatureDepthStencilAttachmentBit) != 0 {
      return f
    }
  }
  return vulkan.FormatD32Sfloat
}</code></pre>
  </section>
  <div class="nav"><a href="index.html">← Back to Hub</a> <a href="step-003-02-renderpass-framebuffers.html">Next →</a></div>
</main>
</body>
</html>
