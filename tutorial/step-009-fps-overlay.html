<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Task 009 – FPS Overlay HUD</title>
  <link rel="stylesheet" href="shared.css">
</head>
<body>
<main>
  <header>
    <h1>Task 009 – FPS Overlay</h1>
    <p class="lead">Render an FPS counter in the top-left using a dedicated overlay pipeline.</p>
  </header>
  <section>
    <h2>Shaders</h2>
<pre><code class="language-glsl">// overlay.vert
#version 450
layout(location=0) in vec2 inPos;
layout(location=1) in vec3 inColor;
layout(location=0) out vec3 fragColor;
void main() { fragColor = inColor; gl_Position = vec4(inPos, 0.0, 1.0); }

// overlay.frag
#version 450
layout(location=0) in vec3 fragColor;
layout(location=0) out vec4 outColor;
void main() { outColor = vec4(fragColor, 1.0); }
</code></pre>
    <p>Compile to <code>overlay_vert.spv</code>, <code>overlay_frag.spv</code>.</p>
  </section>
  <section>
    <h2>Pipeline</h2>
    <ul>
      <li>Vertex format: vec2 position, vec3 color.</li>
      <li>Culling OFF, depth OFF, blend OFF (opaque).</li>
      <li>Separate pipeline/layout from the main cube pipeline.</li>
    </ul>
<pre><code class="language-go">binding := vulkan.VertexInputBindingDescription{
  Binding: 0, Stride: uint32(unsafe.Sizeof(overlayVertex{})),
  InputRate: vulkan.VertexInputRateVertex,
}
attrs := []vulkan.VertexInputAttributeDescription{
  {Location:0, Binding:0, Format: vulkan.FormatR32g32Sfloat, Offset: uint32(unsafe.Offsetof(overlayVertex{}.pos))},
  {Location:1, Binding:0, Format: vulkan.FormatR32g32b32Sfloat, Offset: uint32(unsafe.Offsetof(overlayVertex{}.color))},
}
depthStencil := vulkan.PipelineDepthStencilStateCreateInfo{
  SType: vulkan.StructureTypePipelineDepthStencilStateCreateInfo,
  DepthTestEnable: vulkan.False,
  DepthWriteEnable: vulkan.False,
  DepthCompareOp: vulkan.CompareOpAlways,
}</code></pre>
  </section>
  <section>
    <h2>Data generation</h2>
    <ul>
      <li>Define a tiny bitmap font as strings of 1/0 per character.</li>
      <li>For text like “FPS: 60.0”, expand chars into quads in pixel space, then convert to NDC.</li>
      <li>Write vertices into a host-visible overlay vertex buffer; record a single indirect draw using an overlay indirect buffer.</li>
    </ul>
<pre><code class="language-go">verts := a.buildOverlayVertices(fmt.Sprintf("FPS: %.1f", a.fpsValue))
size := vulkan.DeviceSize(len(verts)) * vulkan.DeviceSize(unsafe.Sizeof(overlayVertex{}))
vulkan.MapMemory(a.device, a.overlayVertexBufferMemory, 0, size, 0, &data)
dst := (*[1<<30]byte)(data)[:size:size]
src := (*[1<<30]byte)(unsafe.Pointer(&verts[0]))[:size:size]
copy(dst, src)
vulkan.UnmapMemory(a.device, a.overlayVertexBufferMemory)

draw := vulkan.DrawIndirectCommand{
  VertexCount:   uint32(len(verts)),
  InstanceCount: 1,
}
// write draw into overlayIndirectMemory, then vkCmdDrawIndirect(cb, overlayIndirectBuffer, 0, 1, sizeof(draw))
</code></pre>
    <p>Converting pixel quad to NDC (inside <code>quadToVertices</code>):</p>
<pre><code class="language-go">toNDC := func(px, py float32) mgl32.Vec2 {
  nx := (px/float32(extent.Width))*2 - 1
  ny := (py/float32(extent.Height))*2 - 1
  return mgl32.Vec2{nx, ny}
}
p0 := toNDC(x, y); p1 := toNDC(x+w, y); p2 := toNDC(x+w, y+h); p3 := toNDC(x, y+h)
return []overlayVertex{
  {pos: p0, color: color}, {pos: p1, color: color}, {pos: p2, color: color},
  {pos: p2, color: color}, {pos: p3, color: color}, {pos: p0, color: color},
}</code></pre>
  </section>
  <section>
    <h2>FPS calculation</h2>
    <ul>
      <li>Track frames and elapsed time; every 1s, set <code>fpsValue = frames / seconds</code>, reset counter/time.</li>
      <li>Update overlay vertices each frame with the current string.</li>
    </ul>
  </section>
  <section>
    <h2>Draw order</h2>
    <ol>
      <li>Draw cube first (color+depth).</li>
      <li>Bind overlay pipeline and vertex buffer; <code>vkCmdDrawIndirect</code> for the overlay.</li>
    </ol>
  </section>
  <section>
    <h2>Extra tips</h2>
    <p><strong>Pipeline separation.</strong> The overlay pipeline uses no depth and a simpler vertex format; keep it in its own layout/pipeline so you don’t accidentally change cube state.</p>
    <p><strong>Synchronization.</strong> The overlay uses the same command buffer and subpass as the cube; no extra semaphores are needed. Just ensure the overlay draw happens after the cube draw in the command buffer.</p>
    <p><strong>Origin.</strong> Characters are built in pixel space with (0,0) in the top-left for readability, then remapped to NDC. Adjust <code>overlayPadding</code> to move the text inward if it touches the border after resize.</p>
<pre><code class="language-go">func (a *VulkanApp) recordOverlay(cmd vulkan.CommandBuffer, extent vulkan.Extent2D) {
  vulkan.CmdBindPipeline(cmd, vulkan.PipelineBindPointGraphics, a.overlayPipeline)
  offset := []vulkan.DeviceSize{0}
  vulkan.CmdBindVertexBuffers(cmd, 0, 1, []vulkan.Buffer{a.overlayVertexBuffer}, offset)
  vulkan.CmdDrawIndirect(cmd, a.overlayIndirectBuffer, 0, 1, uint32(unsafe.Sizeof(vulkan.DrawIndirectCommand{})))
}</code></pre>
    <p>Run with validation on once after adding the overlay—incorrect vertex strides or attribute offsets are common mistakes that validation can catch.</p>
  </section>
  <div class="nav"><a href="index.html">← Back to Hub</a> <a href="step-010-split-modules.html">Next →</a></div>
</main>
</body>
</html>
