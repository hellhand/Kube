<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Task 002 – Instance, Surface, Device Milestone</title>
  <link rel="stylesheet" href="shared.css">
</head>
<body>
<main>
  <header>
    <h1>Task 002 – Instance, Surface, and Device</h1>
    <p class="lead">Create a Vulkan instance, hook validation, make the window surface, and build a logical device.</p>
  </header>
  <section>
    <div class="badge">Milestone goal</div>
    <p>By the end, the app starts with a valid instance, debug messenger (if validation exists), a window surface, and a logical device with graphics + present queues.</p>
  </section>
  <section>
    <h2>Code sketch</h2>
<pre><code class="language-go">// instance + validation
exts := glfw.GetRequiredInstanceExtensions()
validationLayers := []string{"VK_LAYER_KHRONOS_validation"}
// create instance with layers if available, then InitInstance
// debug messenger install here (log severity/message)

// surface
glfw.CreateWindowSurface(a.instance, window, nil, &a.surface)

// pick device
// iterate physical devices, ensure graphics+present queues, swapchain support, VK_KHR_swapchain extension

// create logical device
extensions := []string{"VK_KHR_swapchain"}
createInfo := vulkan.DeviceCreateInfo{ /* queue infos + extensions */ }
vulkan.CreateDevice(phys, &createInfo, nil, &a.device)
vulkan.GetDeviceQueue(a.device, graphicsIndex, 0, &a.graphicsQueue)
vulkan.GetDeviceQueue(a.device, presentIndex, 0, &a.presentQueue)</code></pre>
    <p>These pieces will be fleshed out in the next sub-steps.</p>
  </section>
  <section>
    <h2>1) Initialize Vulkan & validation</h2>
    <ul>
      <li>Call <code>vulkan.SetGetInstanceProcAddr(glfw.GetVulkanGetInstanceProcAddress())</code>, then <code>vulkan.Init()</code>.</li>
      <li>Request validation layers (<code>VK_LAYER_KHRONOS_validation</code>) if available; otherwise log and continue.</li>
      <li>Create a debug messenger/callback to log validation messages.</li>
    </ul>
  </section>
  <section>
    <h2>2) Create the surface</h2>
    <ul>
      <li>Use <code>glfw.CreateWindowSurface(instance, window, nil, &surface)</code> (via vulkan-go bindings).</li>
      <li>Store the surface handle for swapchain creation later.</li>
    </ul>
  </section>
  <section>
    <h2>3) Pick a physical device</h2>
    <ul>
      <li>Enumerate devices; for each, check:
        <ul>
          <li>Queue families: one supports graphics, one supports present (can be same index).</li>
          <li>Device extension support: <code>VK_KHR_swapchain</code>.</li>
          <li>Swapchain support: at least one format and present mode.</li>
        </ul>
      </li>
      <li>Prefer discrete GPU if multiple candidates.</li>
    </ul>
  </section>
  <section>
    <h2>4) Create logical device & queues</h2>
    <ul>
      <li>Specify queue create infos for graphics (and present if distinct).</li>
      <li>Enable device extension <code>VK_KHR_swapchain</code>.</li>
      <li>Retrieve graphics and present queues with <code>GetDeviceQueue</code>; store them.</li>
    </ul>
  </section>
  <section>
    <h2>5) Quick sanity run</h2>
<pre><code>go run .
# Should log instance/device created and exit (no drawing yet).</code></pre>
  </section>
  <section>
    <h2>Deep dive notes</h2>
    <p><strong>Binding Vulkan to GLFW.</strong> The very first Vulkan call should be <code>vulkan.SetGetInstanceProcAddr(glfw.GetVulkanGetInstanceProcAddress())</code> followed by <code>vulkan.Init()</code>. This wires the loader to GLFW’s function resolver so the binding can fetch extension entry points.</p>
    <p><strong>Graceful validation fallback.</strong> Wrap the layer request in a helper that checks availability. If missing, log <em>“validation layers not available; continuing without them”</em> and proceed. This mirrors the runtime logs you may already have seen.</p>
    <p><strong>Queue ownership.</strong> Store <code>graphicsQueue</code> and <code>presentQueue</code> directly on the app struct. Future steps (command submission, presentation) read from there to avoid re-querying.</p>
<pre><code class="language-go">type VulkanApp struct {
  instance vulkan.Instance
  surface  vulkan.Surface
  device   vulkan.Device
  graphicsQueue vulkan.Queue
  presentQueue  vulkan.Queue
  // ...
}</code></pre>
    <p>When the above fields are populated and the program exits cleanly, you’ve hit the milestone.</p>
  </section>
  <div class="nav"><a href="index.html">← Back to Hub</a> <a href="step-002-01-instance-validation.html">Next →</a></div>
</main>
</body>
</html>
